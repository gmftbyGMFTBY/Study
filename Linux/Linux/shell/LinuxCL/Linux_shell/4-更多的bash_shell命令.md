### More Bash Shell Command

#### 监控程序运行

在当今的图形化的时代中,每一个应用程序中的运行着大量的程序,我们需要一种直观的手法了解到运行着的程序的情况,命令行就是

##### ps

* 程序运行在主机上就成为进程,ps命令提供强大的功能来观察这些进程

  1. 默认情况下,ps命令只会显示运行在当前控制台下的属于用户的进程

  2. 显示内容有

     PID进程号 , TTY虚拟终端编号 , TIME进程已经占用的CPU时长,CMD进程名称

```bash
ps -e    # 显示全部进程
ps -a    # 显示所有的除了控制进程和无终端进程的所有进程
ps -C man,ls,cd,ps,...    # 显示在后面的列表中的命令进程
ps -f    # 详细输出,添加了PPID父亲进程编号,UID使用者,STIME进程启动时间,CMD会打印的更加详细,C进程的CPU利用率
ps -l    # 长输出,打印关于进程的所有的详细信息
# -l参数的打印结果简单介绍
# F    : 内核给进程的系统标记
# S    : 进程状态(O正在运行,S休眠,R可运行正在阻塞等待,Z僵化不存在父进程,T停止状态)
# PRI  : 进程优先级,越大越低
# NI   : 谦让度决定优先级
# ADDR : 进程的内存地址 
# SZ   : 进程资源从虚拟内存中换出需要的交换空间的大致大小
# WCHAN: 进程休眠的内核函数地址
ps --forest    # 跟踪父子进程的关系,使用ASCII的形式打印进程树,关于打印进程树的情况可以参考pstree命令的使用
```

​	   3. 结ps的综合使用参数

```bash
ps -ef | grep ...    # 查找对应的命令是否存在
ps -al --forest    # 详细信息打印
```

##### top

1. ps命令不适合观察频繁换进换出内存的程序,**top可以实时显示进程信息**

   ```bash
   top - 14:41:48 up 3 days,  2:04,  3 users,  load average: 0.06, 0.14, 0.16    # 登录用户数目,平均负载最近1,5,15分钟的平均负载,越大繁忙,2以上很繁忙
   Tasks: 210 total,   1 running, 209 sleeping,   0 stopped,   0 zombie    # 1个运行,209个休眠,0个停止和僵化进程(进程结束父进程无响应)
   %Cpu(s):  1.6 us,  0.9 sy,  0.0 ni, 97.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st    # CPU的目前情况
   KiB Mem :  3927940 total,   360564 free,  1426120 used,  2141256 buff/cache    # 物理内存信息
   KiB Swap:  4075516 total,  4075516 free,        0 used.  1976900 avail Mem     # 交换空间
   #           优先级 谦让  虚拟内存占用   物理内存占用   共享容量  状态 
   PID  USER          PR  NI    VIRT            RES     SHR       S  %CPU %MEM   TIME+     COMMAND          
   970  root          20   0  419072            130048   86912    S   4.0  3.3   5:57.68   Xorg              
   1856 lantian       20   0 1305384            160308   77080    S   2.3  4.1   6:40.40   compiz
   ...
   # 以上是top运行额部分动态显示的静态显示
   ```

2. 参数使用

   在进入top界面的时候我们可以使用很多的参数

   * f : 进入排序选择界面,按照提示选择要排序的字段(s确定,q退出即可更新重排序)
   * d : 设置轮询间隔,默认是3s
   * k : 杀死进程,输入PID杀死
   * q : 退出top

##### kill / killall

1. 进程信号

   在Linux中,进程之间需要利用信号通信,以下是常用的信号

   1 挂起

   9 强行终止

   15 尽可能终止

2. kill

   kill命令可一通过进程PID对进程发送信号,默认发送15号

   杀死进程必须是进程属主或者root用户

   ```bash
   kill -9 PID    # 强行杀死进程 
   kill %num    # 按照作业号杀死后台作业
   ```

3. killall

   支持使用通配符利用进程名而不死PID杀死进程

##### mount

1. 了解到电脑上现在挂在的设备的名称和详细的信息可以使用辅助命令`fdisk -l`(注意没有mount的设备还是可以看到的)

2. 什么是挂载,我们将我们的外部设备连接到Linux设备上的时候有时候会自动的挂载并奉陪挂载点连入**虚拟目录**(只有外部设备被挂载到了虚拟目录上,我们才可以通过命令操作这些设备里面的文件),但是我们遇到了不支持的情况就需要手动挂载我们的设备,这就要使用到mount命令

3. mount的挂载含义就是在虚拟木下面开一个别名(挂载点),这个挂载点指向我们的外部设备,但是如果原位置存在有文件,那么显然这些文件会被隐藏直到我们umount之后才可以看到,**所以应该把我们的设备挂载到空目录下**

4. 信息获取的方式

   ```bash
   sudo fdisk -l     # 和内核链接的设备,可以不用挂载也会显示出来详细信息
   vim /etc/mtab     # 显示已经挂载的设备,和mount的作用是一样的
   mount     # 默认输出当前的已经挂载的设备
   # mount命令获取的信息的格式是  设备名 挂载点名  文件系统名称  挂载的设备的访问状态
   ```

5. 挂载

   使用root管理员权限才可以挂载设备

   ```bash
   mount -t type /dev/sdb1 dir    # 将设备状态是type(vfat , ntfs都是windows下被格式化的u盘)设备/dev/sdb1挂载到空目录dir下
   # 挂在之后root就拥有了对该目录的操作权限
   # 参数
   # -t type 制定挂载的文件类型,一般的发行版都会默认的识别,但是最好还是自己指定
   # -v 打印挂载过程中的必要信息
   # -r 只读挂载
   # -w 设备可读写
   # 这里非常需要记录一下笔记,如果u盘在linux下是只读但是在windows下都可以正常读写,并且linux下的mount方式是rw可以考虑使用命令
   #  fsck -C -a /dev/sdb1  自动修复受损的u盘
   # 经过试验发现,我们只能使用自动挂载实现读写手动挂载是不会实现读写的(虽然显示是读写)

   # 小心权限不够不是root，挂在后没有办法使用
   ```

##### umount

卸载设备

```bash
umount /dev/sdb1    # 从虚拟目录中卸载设备
# 如果显示是busy,请退出设备的工作目录重试还有可能正在使用这个设备的文件,先退出进程在重试,如果显示不允许执行请使用sudo
```

##### df

1. df 可以显示我们的存储设备上还有多少的存储空间在**已挂载的设备**上
2. df默认会显示当前已经挂载上的所有的设备的容量使用情况
3. 显示的大小是字节为单位
4. -h参数和ls -lh是一个意思,讲字节为单位转边成基本容量单位

##### du

1. 发现某一个磁盘的存储空间快结束的时候,可以使用du命令检测某一个目录下的文件的磁盘使用情况,**默认当前目录**
2. 只是用du命令我们可以看出来当前目录下的文件和文件夹的存储大小(磁盘块数单位)自文件树底向上显示

```bash
du .    # 默认的输出格式
du -s . != du -s ./*    # 前者统计一个目录当前目录的统计结果,后者统计当前目录下的所有文件的结果
# 一句话总结,du统计的是参数(目标文件或者目录)记以下文件树所有节点的结果,.只统计当前目录,./* || * 统计当前目录下的所有文件及其以下文件数的所有节点
```

参数

* -c : 显示已经列出的文件的总的大小
* -h : 用户易读的方式罗列大小
* -s : 只显示统计结果,显示对目录的统计结果

##### sort

sort命令对数据进行排序,默认采用的是字符的字典序

* -n : 对于数据的话,建议使用-n参数制定是数字
* -M : Linux的日志文件经常在其实位置加入时间戳,对月份进行排序
* -r : 反序,默认升序
* -u : 去重
* -R : 随机打乱
* -t / -k : -t指定我们的分隔符,-k用来制定分割之后的排序字段(1,2...),对于类似CSV的文件用该命令参数排序效果很好

```bash
sort -t ':' -k 3 -n /etc/passwd    # 对用户ID进行排序
du -s * | sort -nr     # 不要使用du的-h参数,否则排序结果错误,使用的是n参数进行排序
```

##### grep

grep命令的简单使用

grep命令可以在制定的**文件组**内容中搜索匹配的串,串使用正则表达式(输出匹配的行)

参数

* -v : 反向搜索,输出不匹配的所有行
* -n : 显示匹配行的行号
* -c : 显示匹配的行的数目
* -e : 参数是制定的匹配模式串,可:q以多次使用-e参数多次指定
* -l : 只显示文件名
* -R : 递归检查目录下文件

````bash
grep pattern file
# 常用的组合
grep -n pattern file
````

##### gzip / zip /  bzip2

zip在windows上非常的常见,在linux系统中我们也可以使用并作为跨平台传递压缩文件的主要格式

Linux系统下最常用的是gzip命令压缩

```bash
gzip file
gzip my*    # 批量压缩文件,每个文件都进行一次压缩操作
gzip -l file.gz    # 列出压缩文件的内容不解压
gzip -d file.gz    # 解压
gzip -v ... # 详细显示执行过程
```

##### tar

tar命令用来对文件或者目录进行归档操作

```bash
tar -cvf test.tar ... ...    # 创建归档文件
tar -tf test.tar      # 罗列归档文件内容
tar -rf test.tar newfile     # 讲newfile文件的更新加入归档文件
tar -xvf test.tar    # 解开归档
tar -zxvf test.tar.gz / test.tgz    # 解开归档并gzip解压
# tar归档不对源文件处理,吹源文件拷贝这和gzip不一样
# 常用参数
# -r / -u : 追加更新文件到归档文件中 
# -x : 抽取归档
# -c : 创建归档
# -f : 指定归档文件
# -v : 详细输出
# -z : 给gzip重定向输出
```



